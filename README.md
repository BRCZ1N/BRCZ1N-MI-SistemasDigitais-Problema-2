
<h1 align="center"> <a href="https://git.io/typing-svg"><img src="https://readme-typing-svg.herokuapp.com?font=Fira+Code&weight=900&size=36&duration=2500&pause=250&color=F7F7F7&background=0D111700&center=true&vCenter=true&multiline=true&width=810&height=100&lines=Tetris+Experimental;Desafios+de+Renderiza%C3%A7%C3%A3o+com+GPU+Simples" alt="Typing SVG" /></a> 
</h1>
ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦ğŸŸªğŸŸ¨ğŸŸ¥ğŸŸ§ğŸŸ¦


<h3 align="justify">Jogo inspirado no clÃ¡ssico Tetris, desenvolvido para o kit de desenvolvimento DE1-SoC utilizando linguagem C e Assembly </h3>


<div align="justify" id="sobre-o-projeto"> 
<h2> Sobre o Projeto</h2>

Este projeto se concentra no gerenciamento de uma Unidade de Processamento GrÃ¡fico (GPU) especializada, desenvolvida para manipulaÃ§Ã£o de saÃ­das grÃ¡ficas em sistemas computacionais. TambÃ©m conhecida como placa de vÃ­deo, a GPU Ã© responsÃ¡vel por aliviar a CPU de tarefas intensas relacionadas Ã  renderizaÃ§Ã£o de grÃ¡ficos, que demanda cÃ¡lculos complexos e frequentes.

Diferente de outros componentes de hardware, uma GPU possui uma estrutura relativamente sofisticada, composta por unidades de lÃ³gica aritmÃ©tica, registradores, e atÃ© memÃ³ria dedicada, alÃ©m de, em alguns casos, uma ISA prÃ³pria para executar operaÃ§Ãµes grÃ¡ficas especÃ­ficas. A interaÃ§Ã£o com a GPU requer um software especializado que realize o gerenciamento adequado do dispositivo e estabeleÃ§a uma comunicaÃ§Ã£o eficiente com o sistema, garantindo que os sinais digitais corretos sejam gerados para cada operaÃ§Ã£o.

Nesse contexto, o problema 2 do mÃ³dulo integrador TEC499 - SISTEMAS DIGITAIS do curso de Engenharia de ComputaÃ§Ã£o da UEFS propÃµe a criaÃ§Ã£o de uma biblioteca em linguagem assembly para ARMv7, focada no gerenciamento da GPU. A GPU utilizada neste projeto foi projetada por Gabriel SÃ¡ Barreto Alves como parte de sua iniciaÃ§Ã£o cientÃ­fica e trabalho de conclusÃ£o de curso, implementada em uma FPGA no kit DE1-SoC.

Este relatÃ³rio aborda a construÃ§Ã£o desse sistema de gerenciamento para a GPU, explicando o desenvolvimento da biblioteca em assembly, a lÃ³gica de controle da GPU e a comunicaÃ§Ã£o com o dispositivo, tudo integrado ao ambiente de desenvolvimento DE1-SoC para execuÃ§Ã£o.

Os requisitos para elaboraÃ§Ã£o do sistema sÃ£o apresentados a seguir:

* O cÃ³digo da biblioteca deve ser escrito em linguagem aseembly; 
* A biblioteca deve conter as funÃ§Ãµes essenciais para que seja possÃ­vel implementar a parte grÃ¡fica do jogo usando o Processador GrÃ¡fico;

<h2>  Equipe: <br></h2>
<uL> 
  <li><a href="https://github.com/Oguelo">Alex da Fonseca Dantas Junior</a></li>
  <li><a href="https://github.com/BRCZ1N">Bruno Campos de Oliveira Rocha</a></li>
  <li><a href="https://github.com/duasck">Luis Eduardo Leite Azevedo</a></li>
</ul>
</div>

<h1 align="center"> SumÃ¡rio </h1>
<div id="sumario">
    <ul>
       <li><a href="#IntroduÃ§Ã£o">IntroduÃ§Ã£o</a></li>
        <li><a href="#Metodologia">Metodologia</a></li>
        <li><a href="#Resultados">Resultados</a></li>
        <li><a href="#makefile">Makefile</a></li>  
        <li><a href="#conclusao">ConclusÃ£o</a></li>
        <li><a href="#referencia">ReferÃªncias</a></li>
  </ul>
</div>

<div align="justify" id="equipamentos"> 
<h2> DescriÃ§Ã£o dos Equipamentos e Software Utilizados</h2>

Nesta seÃ§Ã£o, sÃ£o apresentados os equipamentos e software utilizados durante o desenvolvimento do projeto.

<h3>Kit de desenvolvimento DE1-SoC</h3>

A placa DE1-SoC Ã© um kit de desenvolvimento que integra um processador ARM Cortex-A9 dual-core com um FPGA Cyclone V da Intel, proporcionando uma poderosa plataforma para projetos que combinam software e hardware. Com uma ampla variedade de perifÃ©ricos, como portas VGA, Ethernet, USB, e Ã¡udio, a DE1-SoC Ã© ideal para aplicaÃ§Ãµes em sistemas embarcados e FPGA. Devido Ã  sua versatilidade, essa placa Ã© amplamente utilizada em ambientes educacionais e de pesquisa, facilitando o aprendizado e o desenvolvimento de projetos em ambas as Ã¡reas.
Abaixo estÃ£o os elementos utilizados na construÃ§Ã£o desse projeto:

<h3> Linguagem C</h3>
A linguagem C foi escolhida por sua eficiÃªncia, portabilidade e ampla aplicaÃ§Ã£o em sistemas embarcados. Com uma sintaxe simples, ela oferece controle preciso sobre o hardware, alÃ©m de contar com bibliotecas padrÃ£o e ferramentas que facilitam o desenvolvimento de cÃ³digo compacto e otimizado, ideal para dispositivos com recursos limitados.

<h3> Linguagem Assembly</h3>
A linguagem assembly foi escolhida por sua capacidade de oferecer controle direto sobre o hardware, permitindo o mÃ¡ximo de otimizaÃ§Ã£o e eficiÃªncia em sistemas embarcados. Com uma sintaxe prÃ³xima ao cÃ³digo de mÃ¡quina, o assembly possibilita o uso especÃ­fico de registradores e instruÃ§Ãµes, aproveitando ao mÃ¡ximo os recursos da arquitetura ARMv7. Essa escolha Ã© ideal para aplicaÃ§Ãµes em que desempenho e controle absoluto sobre o processamento sÃ£o essenciais, especialmente em dispositivos com recursos limitados, onde o gerenciamento preciso do hardware Ã© fundamental.

<h3> Compilador GNU</h3>

O GCC, abreviaÃ§Ã£o de "GNU Compiler Collection" (ColeÃ§Ã£o de Compiladores GNU), Ã© uma popular distribuiÃ§Ã£o de compiladores que oferece suporte a diversas linguagens de programaÃ§Ã£o, como C, C++, Objective-C, Fortran e Ada. Quando executado, o GCC realiza vÃ¡rias etapas, incluindo prÃ©-processamento, compilaÃ§Ã£o, montagem e vinculaÃ§Ã£o. Ele tambÃ©m disponibiliza uma ampla variedade de opÃ§Ãµes de linha de comando, permitindo que o desenvolvedor personalize o processo de compilaÃ§Ã£o conforme suas necessidades especÃ­ficas

<h3>Vistual Studio Code</h3>

O Visual Studio Code, conhecido como VSCode, Ã© um ambiente de desenvolvimento amplamente usado. Desenvolvido pela Microsoft, Ã© um editor de cÃ³digo gratuito e de cÃ³digo aberto com recursos como realce de sintaxe, conclusÃ£o de cÃ³digo e depuraÃ§Ã£o integrada. Suporta vÃ¡rias linguagens e possui extensÃµes para personalizaÃ§Ã£o. No projeto ele foi utilizado para desenvolver o cÃ³digo fonte do jogo.

<h3> Monitor CRT</h3>

O monitor utilizado no projeto foi o DELL M782p, um modelo de CRT que utiliza tubo de raios catÃ³dicos para exibiÃ§Ã£o de imagens. Com uma tela de 17 polegadas e resoluÃ§Ã£o mÃ¡xima de 1280x1024 pixels, ele oferece uma interface VGA para conexÃ£o com computadores ou placas de desenvolvimento. Os monitores CRT, como o DELL M782p, sÃ£o conhecidos por sua reproduÃ§Ã£o de cores vibrantes e tempos de resposta rÃ¡pidos, tornando-os ideais para projetos que exigem interaÃ§Ã£o em tempo real, como jogos e simulaÃ§Ãµes.


Abaixo estÃ£o dados detalhados sobre o monitor usado:

|            CaracterÃ­sticas            |      Detalhes      |
| :------------------------------------: | :----------------: |
|       **Tipo de Display**       |      Vertical      |
| **Tamanho da Tela (Horizontal)** |      32,4 cm      |
|  **Tamanho da Tela (Vertical)**  |      24,6 cm      |
|  **Tamanho da Tela (Diagonal)**  |      40,6 cm      |
|      **Varredura Vertical**      |    50 - 160 Hz    |
|     **Varredura Horizontal**     |    30 - 70 kHz    |
|  **Tamanho da Tela (Diagonal)**  |   43,2 cm (17")   |
|          **Dot Pitch**          |  0,270 x 0,270 mm  |
|     **ResoluÃ§Ã£o MÃ¡xima**     | 1280 x 1024 pixels |
|    **ResoluÃ§Ã£o do Display**    | 1024 x 768 pixels |

</div>


<div align="justify" id="arq_CPU">
<h2> Estrutura da Placa DE1-SoC </h2>

Nesta parte, serÃ¡ detalhada a arquitetura da placa DE1-SoC, incluindo o processador ARM Cortex-A9, a organizaÃ§Ã£o dos registradores, o mapeamento dos dispositivos de entrada/saÃ­da na memÃ³ria, o uso da memÃ³ria, a comunicaÃ§Ã£o entre o processador e o FPGA, alÃ©m do processo de compilaÃ§Ã£o nativa diretamente na placa.

<h3>Resumo dos Recursos do Processador ARM Cortex-A9 </h3>

O ARM Cortex-A9 Ã© baseado em uma arquitetura RISC (Reduced Instruction Set Computing), onde operaÃ§Ãµes aritmÃ©ticas e lÃ³gicas sÃ£o realizadas nos registradores de propÃ³sito geral. A movimentaÃ§Ã£o de dados entre memÃ³ria e registradores Ã© feita atravÃ©s de instruÃ§Ãµes Load e Store, com comprimento de palavra de 32 bits e endereÃ§amento em estilo little-endian.

<h3>OrganizaÃ§Ã£o dos Registradores</h3>

O processador ARM Cortex-A9 contÃ©m 15 registradores de propÃ³sito geral (R0 a R14), um contador de programa (R15) e um registrador de status do programa atual (CPSR), todos com 32 bits. Dois registradores tÃªm tratamento especial: R13 Ã© o Stack Pointer, enquanto R14 atua como registrador de link em chamadas de sub-rotina.

<h3>InstruÃ§Ãµes e Modo Thumb</h3>

As instruÃ§Ãµes tÃªm 32 bits e sÃ£o armazenadas na memÃ³ria com alinhamento de palavras. O conjunto de instruÃ§Ãµes Thumb oferece uma versÃ£o reduzida com instruÃ§Ãµes de 16 bits, o que diminui os requisitos de memÃ³ria, algo Ãºtil em sistemas embarcados.

<h3>MemÃ³ria Utilizada</h3>

O HPS (Hard Processor System) conta com uma interface de memÃ³ria que conecta o ARM MPCORE a uma memÃ³ria DDR3 de 1 GB. Esta memÃ³ria serve como armazenamento de dados e programas para os processadores ARM. Organizada como 256M x 32 bits, ela pode ser acessada por palavras de 32 bits, meias palavras e bytes.

<h3>Mapeamento de Dispositivos de Entrada/SaÃ­da</h3>

Os dispositivos de E/S disponÃ­veis ao processador ARM sÃ£o mapeados diretamente na memÃ³ria e acessados como se fossem endereÃ§os de memÃ³ria, utilizando as instruÃ§Ãµes Load e Store.

<h3>InterrupÃ§Ãµes de Hardware</h3>

Dispositivos de E/S podem gerar interrupÃ§Ãµes de hardware, ativando as linhas de solicitaÃ§Ã£o de interrupÃ§Ã£o (IRQ ou FIQ) do processador. Quando ocorre uma interrupÃ§Ã£o, o processador entra no modo de exceÃ§Ã£o correspondente e salva o estado atual do programa. Antes de retornar Ã  execuÃ§Ã£o, o endereÃ§o salvo no registrador de link deve ser decrementado em 4.

<h3>Diagrama de Blocos da Placa DE1-SoC</h3>

O sistema DE1-SoC Ã© composto pelo HPS e pelo FPGA, ambos integrados no chip Cyclone V SoC. O HPS inclui um processador ARM Cortex-A9 dual-core, uma interface de memÃ³ria DDR3 e perifÃ©ricos. O FPGA implementa dois processadores Intel Nios II e vÃ¡rios perifÃ©ricos conectados.

<h3>CompilaÃ§Ã£o Nativa na DE1-SoC</h3>

A compilaÃ§Ã£o nativa ocorre quando o cÃ³digo Ã© compilado no mesmo sistema em que serÃ¡ executado. Aqui, a compilaÃ§Ã£o serÃ¡ realizada diretamente na placa, utilizando a linha de comando do Linux e as ferramentas de compilaÃ§Ã£o integradas. O comando `gcc` invoca o GNU C Compiler, um compilador de cÃ³digo aberto muito usado para gerar executÃ¡veis no Linux.

</div>

## Metodologia

### Funcionamento da GPU

Para controlar a GPU, foi necessÃ¡rio entender a arquitetura e os modos de comunicaÃ§Ã£o desta unidade grÃ¡fica. A GPU utiliza instruÃ§Ãµes de 64 bits e se comunica atravÃ©s dos barramentos de dados `DATA A` e `DATA B`. Abaixo, Ã© detalhado o funcionamento da GPU:

- **InstruÃ§Ãµes de 64 Bits**: A GPU opera com instruÃ§Ãµes de 64 bits, onde o campo `opcode` (4 bits) no inÃ­cio da palavra identifica o tipo de operaÃ§Ã£o. Dependendo da instruÃ§Ã£o, a palavra Ã© dividida entre `DATA A` e `DATA B`. Quando o sinal `START` recebe um nÃ­vel lÃ³gico alto, os valores de `DATA A` e `DATA B` sÃ£o inseridos nas filas FIFO de instruÃ§Ã£o, e a GPU processa os dados conforme a operaÃ§Ã£o indicada.

- **Controle de FIFO**: Um barramento de saÃ­da indica o estado das filas FIFO (se estÃ£o cheias), permitindo evitar a perda de instruÃ§Ãµes por excesso de inserÃ§Ã£o.

- **MemÃ³rias de Sprites e Background**: 
  - **MemÃ³ria de Sprites**: Capaz de armazenar atÃ© 31 sprites simultÃ¢neas, cada sprite possui dados de cada pixel individualmente.
  - **MemÃ³ria de Background**: Armazena 4800 blocos de 8x8 pixels, formando uma grade de 80x60 que compÃµe o fundo da tela.
  - **Registradores**: A GPU possui 32 registradores que guardam o endereÃ§o de cada sprite ativa. O registrador 1 Ã© reservado para a cor de background.

- **SaÃ­da em VGA**: A GPU gera uma saÃ­da no formato VGA (640x480 pixels), que Ã© enviada diretamente Ã  porta VGA da placa, sem necessidade de tratamento adicional.

- **Gerenciamento de PolÃ­gonos**: A GPU Ã© capaz de desenhar polÃ­gonos como quadrados ou triÃ¢ngulos de tamanhos predefinidos, selecionados via instruÃ§Ã£o.

### InstruÃ§Ãµes da GPU

A GPU utiliza quatro instruÃ§Ãµes principais, conforme descrito abaixo:

1. **WBR (0000 - Escrita no Banco de Registradores)**: Modifica o endereÃ§o de memÃ³ria referenciado pelo registrador alvo, associando-o a uma sprite especÃ­fica.

2. **WSM (0001 - Escrita na MemÃ³ria de Sprites)**: Altera o valor de um endereÃ§o na memÃ³ria de sprites, modificando o valor de um pixel da sprite.

3. **WBM (0010 - Escrita na MemÃ³ria de Background)**: Modifica a cor de um bloco especÃ­fico no background.

4. **DP  (0011 - DefiniÃ§Ã£o de PolÃ­gono)**: Define um polÃ­gono com tamanho, cor e posiÃ§Ã£o especÃ­ficas, associando-o a um registrador selecionado.

| InstruÃ§Ã£o                               | ParÃ¢metros                             |
|-----------------------------------------|:--------------------------------------:|
| WBR_GB                        | R, G, B                                          |
| WBR_S                         | reg, offset, R, G, B                             |
| WSM                           | reg, pixel, R, G, B                              |
| WBM                           | mem_address, R, G, B                             |
| DP                      | address, ref_point_x, ref_point_y, size, R, G, B, shape|


|            VariÃ¡vel            |      Significado      | Intervalo |
| :------------------------------------: | :----------------: |:----------------: |
| R | Intensidade do vermelho | 0 - 7 |
| G | Intensidade do verde | 0 - 7 |
| B | Intensidade do azul | 0 - 7 |
| X | Coordenada em relaÃ§Ã£o ao eixo X | 0 - 640 |
| Y | Coordenada em relaÃ§Ã£o ao eixo Y | 0 - 480 |
| reg | Registrador onde os parÃ¢metros serÃ£o armazenados | -- |
| offset | LocalizaÃ§Ã£o do sprite na memoria | -- |
| onScreen | IndicaÃ§Ã£o para mostrar a informaÃ§Ã£o na tela ou nÃ£o | 0 - 1 |
| pixel | EndereÃ§o de um pixel na memoria de sprites | -- |
| ref_point_x | Coordenada do ponto de referÃªncia em relaÃ§Ã£o a X | -- |
| ref_point_y | Coordenada do ponto de referÃªncia em relaÃ§Ã£o a Y | -- |
| size | DimensÃ£o do polÃ­gono | 1 - 12 |
| shape | Formado do polÃ­gono, podendo ser quadrado ou triangulo | 0 - 1 |

### Biblioteca

A biblioteca foi criada com o propÃ³sito de possibilitar a interaÃ§Ã£o do usuÃ¡rio com a GPU, facilitando o envio de instruÃ§Ãµes e dados. Ela abstrai a complexidade do acesso direto aos 
registradores e buffers FIFO da GPU.

As principais funÃ§Ãµes da biblioteca estÃ£o localizadas no arquivo `GpuLib.asm` e incluem:

#### FunÃ§Ã£o de Mapeamento de MemÃ³ria (`gpuMapping`)

ResponsÃ¡vel por abrir o dispositivo de memÃ³ria e mapear o endereÃ§o base de controle da GPU. A funÃ§Ã£o utiliza chamadas de sistema para abrir e mapear a memÃ³ria, permitindo o acesso direto aos registradores da GPU.

#### FunÃ§Ã£o de Fechamento de Mapeamento (`closeGpuMapping`)

Finaliza o mapeamento de memÃ³ria, liberando os recursos e fechando o descritor de arquivo do dispositivo. Garante que a memÃ³ria mapeada seja liberada corretamente, evitando erros em caso de mÃºltiplas chamadas.

#### FunÃ§Ã£o de VerificaÃ§Ã£o de FIFO Cheia (`isFull`)

Verifica se o FIFO da GPU estÃ¡ cheio antes de enviar uma nova instruÃ§Ã£o. A funÃ§Ã£o checa o estado do FIFO e retorna um valor indicando se ele estÃ¡ ocupado.

#### FunÃ§Ã£o de Envio de InstruÃ§Ãµes (`sendInstruction`)

Envia uma instruÃ§Ã£o para a GPU. Antes de enviar, a funÃ§Ã£o verifica o status do FIFO, e, se disponÃ­vel, envia as instruÃ§Ãµes apropriadas nos barramentos correspondentes(DATA_A e DATA_B) para o dispositivo.

#### FunÃ§Ãµes de ConfiguraÃ§Ã£o de GrÃ¡ficos

FunÃ§Ãµes para configurar diversos aspectos grÃ¡ficos da tela, incluindo:

- **Cor de Fundo (`setBackgroundColor`)**: Define a cor de fundo da tela utilizando valores RGB, utilizando a instruÃ§Ã£o **WBR** para escrever a cor no registrador no banco de registradores.

- **Blocos de Fundo (`setBackgroundBlock`)**: Permite configurar a cor de blocos especÃ­ficos no plano de fundo da tela. Utiliza a instruÃ§Ã£o **WBM** para escrever diretamente na memÃ³ria de background, alterando as cores dos blocos de 8x8 pixels.

- **Sprites (`setSprite`)**: Define a posiÃ§Ã£o, offset e visibilidade das sprites na tela. Usa a instruÃ§Ã£o **WBR** para configurar o registrador do sprite, ajustando sua posiÃ§Ã£o, offset e o bit de ativaÃ§Ã£o que controla a exibiÃ§Ã£o do sprite.

- **PolÃ­gono (`setPolygon`)**: Define polÃ­gonos com propriedades especÃ­ficas, como posiÃ§Ã£o e tamanho, para exibiÃ§Ã£o na tela. Utiliza a instruÃ§Ã£o **DP** para desenhar o polÃ­gono na tela, configurando sua forma (quadrado ou triÃ¢ngulo), tamanho e coordenadas.

Essas funÃ§Ãµes no arquivo `GpuLib.asm` oferecem uma interface simplificada para manipulaÃ§Ã£o da GPU, possibilitando o envio de comandos especÃ­ficos sem a necessidade de acesso direto aos registradores e buffers FIFO.

#### AdaptaÃ§Ã£o de funÃ§Ãµes do jogo anterior

Usando essas funÃ§Ãµes das bibliotecas desenvolvemos novas funÃ§Ãµes para o jogo sÃ£o elas: 

- `drawBoard`: Esta funÃ§Ã£o Ã© responsÃ¡vel por desenhar o estado atual do tabuleiro do jogo. 
- `videoBox`: Esta funÃ§Ã£o existia na primeira versÃ£o do game, onde, ao receber coordenadas iniciais e finais (x, y) e uma cor RGB, criava blocos grÃ¡ficos na tela. Para manter a compatibilidade com a estrutura original do jogo, recriamos essa funÃ§Ã£o na nova versÃ£o.
- `convertHexToRgb`: A funÃ§Ã£o `convertHexToRgb` Ã© necessÃ¡ria porque o `videoBox` recebe uma cor em formato hexadecimal RGB, enquanto nossa GPU exige um valor de 8 bits para cada componente de cor (`R`, `G` e `B`), com intensidade variando de 0 a 7. Assim, criamos essa funÃ§Ã£o para converter as cores para o formato compatÃ­vel com a GPU.
- `generateBox`: Esta funÃ§Ã£o gera um bloco colorido no fundo, posicionando-o em uma localizaÃ§Ã£o especÃ­fica baseada em coordenadas de coluna e linha (column e line). Recebe os valores de cor em componentes RGB (`R`, `G`, `B`) e o comprimento do bloco (length).
- `videoClear`: Limpa a tela.

## Resultados

Usando essas funÃ§Ãµes das bibliotecas desenvolvemos novas funÃ§Ãµes para o jogo sÃ£o elas: 

- `drawBoard`: Esta funÃ§Ã£o Ã© responsÃ¡vel por desenhar o estado atual do tabuleiro do jogo. 
- `videoBox`: Esta funÃ§Ã£o existia na primeira versÃ£o do game, onde, ao receber coordenadas iniciais e finais (x, y) e uma cor RGB, criava blocos grÃ¡ficos na tela. Para manter a compatibilidade com a estrutura original do jogo, recriamos essa funÃ§Ã£o na nova versÃ£o.
- `convertHexToRgb`: A funÃ§Ã£o `convertHexToRgb` Ã© necessÃ¡ria porque o `videoBox` recebe uma cor em formato hexadecimal RGB, enquanto nossa GPU exige um valor de 8 bits para cada componente de cor (`R`, `G` e `B`), com intensidade variando de 0 a 7. Assim, criamos essa funÃ§Ã£o para converter as cores para o formato compatÃ­vel com a GPU.
- `generateBox`: Esta funÃ§Ã£o gera um bloco colorido no fundo, posicionando-o em uma localizaÃ§Ã£o especÃ­fica baseada em coordenadas de coluna e linha (column e line). Recebe os valores de cor em componentes RGB (`R`, `G`, `B`) e o comprimento do bloco (length).
- `videoClear`: Limpa a tela.

### Funcionamento do jogo 
<div style="display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center;">
    <img src="gifsProjeto/funcionamento.gif" alt="DemonstraÃ§Ã£o da jogabilidade do jogo." />
    <p>DemonstraÃ§Ã£o da jogabilidade do jogo.</p>
</div>
<div style="display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center;">
    <img src="gifsProjeto/pause.gif" alt="DemonstraÃ§Ã£o da marcaÃ§Ã£o de pontos." />
    <p>DemonstraÃ§Ã£o da funÃ§Ã£o de pause.</p>
</div>
<div style="display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center;">
    <img src="gifsProjeto/pontuacao.gif" alt="DemonstraÃ§Ã£o da marcaÃ§Ã£o de pontos." />
    <p>DemonstraÃ§Ã£o da pontuaÃ§Ã£o.</p>
</div>
<div style="display: flex; justify-content: center; align-items: center; flex-direction: column; text-align: center;">
    <img src="gifsProjeto/gameOver.gif" alt="DemonstraÃ§Ã£o da marcaÃ§Ã£o de pontos." />
    <p>DemonstraÃ§Ã£o do game over.</p>
</div>

<div align="justify" id="makefile"> 
<h2>Makefile</h2>

Para atender aos requisitos e simplificar o processo de compilaÃ§Ã£o e execuÃ§Ã£o do projeto, foi gerado um `Makefile`. Este arquivo serve como uma ferramenta que automatiza a construÃ§Ã£o do projeto, facilitando o gerenciamento do processo de compilaÃ§Ã£o. O `Makefile` executa as seguintes operaÃ§Ãµes:

- **CompilaÃ§Ã£o**: Compila os arquivos de cÃ³digo-fonte em arquivos objeto.
- **Linkagem**: Combina os arquivos objeto em um executÃ¡vel.
- **Limpeza**: Remove arquivos temporÃ¡rios e o executÃ¡vel gerado.
- **ExecuÃ§Ã£o**: Permite iniciar o programa compilado.

</div>

<div  align="justify" id="execucao"> 
<h2>Guia de InstalaÃ§Ã£o e ExecuÃ§Ã£o</h2>

Para iniciar o projeto, siga os passos abaixo para obter o cÃ³digo-fonte, compilar o cÃ³digo e executÃ¡-lo em um dispositivo FPGA DE1-SoC.

**Passo 1: Clonar o RepositÃ³rio**

Abra o terminal e execute o seguinte comando para obter o cÃ³digo do repositÃ³rio:

    git clone https://github.com/BRCZ1N/MI-SistemasDigitais-Problema-2.git

**Passo 2: Acessar o DiretÃ³rio**

    cd MI-SistemasDigitais-Problema-2\Modules

**Passo 3: Compile e execute o cÃ³digo usando o comando:**

    make 

</div>

<div div align="justify" id="conclusao"> 
<h2> ConclusÃ£o</h2>

O desenvolvimento deste projeto de Tetris para a placa DE1-SoC, utilizando linguagem C, demonstrou a versatilidade e o poder de integraÃ§Ã£o entre hardware e software oferecidos por essa plataforma. Ao implementar o jogo, foi possÃ­vel explorar a interface grÃ¡fica transmitida via VGA, o controle responsivo utilizando um acelerÃ´metro e botÃµes, alÃ©m da manipulaÃ§Ã£o de memÃ³ria e dispositivos de entrada/saÃ­da diretamente no hardware. Entretanto, nÃ£o foi possÃ­vel implementar recursos, tais como, rotaÃ§Ã£o de tetrominos e aumento de nÃ­vel com base na pontuaÃ§Ã£o, esses recursos gerariam ainda mais diversidade e sÃ£o possÃ­veis de serem feitos com esse projeto base.
O projeto proporcionou uma oportunidade  de combinar conceitos de sistemas embarcados, como controle de perifÃ©ricos, algoritmos de movimentaÃ§Ã£o e colisÃ£o, e lÃ³gica de geraÃ§Ã£o e remoÃ§Ã£o de peÃ§as, em uma aplicaÃ§Ã£o prÃ¡tica e divertida. A utilizaÃ§Ã£o da DE1-SoC permitiu expandir o conhecimento sobre FPGAs, alÃ©m de aprimorar as habilidades de programaÃ§Ã£o em C para sistemas com recursos limitados.
<li><a href="#sumario">Voltar para o inicio</a></li>
 
</div>

<div id="referencia"> 
<h2> ReferÃªncias</h2>
<ul>
<li><a href="https://ftp.intel.com/Public/Pub/fpgaup/pub/Intel_Material/18.1/Computer_Systems/DE1-SoC/DE1-SoC_Computer_ARM.pdf">DE1-SoC Computer System with ARM* Cortex* A9 </a> - Acesso em 26 set. 2024. </li>
<li><a href="https://blogs.vmware.com/vsphere/2020/03/how-is-virtual-memory-translated-to-physical-memory.html"> NIELS HAGOORT. How is Virtual Memory Translated to Physical Memory? VMware vSphere Blog. </a> - Acesso em: 20 set. 2024.</li>
<li><a href="https://ftp.intel.com/Public/Pub/fpgaup/pub/Intel_Material/17.0/Tutorials/Linux_On_DE_Series_Boards.pdf" > Using Linux* on DE-series Boards </a> - Acesso em 24 set 2024.</li>
â€Œ</ul>
</div>
